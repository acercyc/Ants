<!DOCTYPE html>
<html>
<head>
  <title>Ant Simulation (ABM + Canvas)</title>
  <meta charset="utf-8">
  <style>
    body { margin: 0; overflow: hidden; background-color: #111; }
    canvas { display: block; }
  </style>
</head>
<body>
<canvas id="antCanvas"></canvas>
<script>
// --- Simulation Parameters ---
const NUM_ANTS = 100;
const ANT_SPEED = 2;
const SPEED_VARIANCE = 0.7; // Standard deviation for speed (Gaussian)
const ANT_SIZE = 8;
const WANDER_STRENGTH = 0.3;
const BOUNDARY_TURN_STRENGTH = 2;
const ARENA_PADDING = 20;
const BOUNDARY_TURN_NOISE = 0.2;
const PAUSE_TIME_MIN = 20; // Minimum pause frames
const PAUSE_TIME_MAX = 80; // Maximum additional random pause frames
const INFO_BUFFER_MAX = 100;
const INFO_EXCHANGE_AMOUNT = 10;
const GOSSIP_RANGE = ANT_SIZE * 6;
const INFO_ACCUM_RATE = 0.1; // <--- How quickly distance accumulates information
const GOSSIP_MEMORY_SIZE = 3;  // <--- max number of partners remembered

// --- Global Variables ---
let ants = [];
let arenaRadius;
let centerX, centerY;
let canvas, ctx;

function calculateArena() {
  centerX = window.innerWidth / 2;
  centerY = window.innerHeight / 2;
  arenaRadius = Math.min(centerX, centerY) - ARENA_PADDING;
}

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  calculateArena();
}

function randomGaussian(mean = 0, stddev = 1) {
  // Box-Muller transform
  let u = 0, v = 0;
  while(u === 0) u = Math.random();
  while(v === 0) v = Math.random();
  return mean + stddev * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}

function init() {
  canvas = document.getElementById('antCanvas');
  ctx = canvas.getContext('2d');
  resizeCanvas();
  ants = [];
  for (let i = 0; i < NUM_ANTS; i++) {
    const angle = Math.random() * Math.PI * 2;
    const radius = Math.random() * arenaRadius * 0.9;
    const startX = centerX + Math.cos(angle) * radius;
    const startY = centerY + Math.sin(angle) * radius;
    // Gaussian distributed speed, clamp to minimum 0.2
    let speed = Math.max(0.2, randomGaussian(ANT_SPEED, SPEED_VARIANCE));
    ants.push({
      x: startX,
      y: startY,
      angle: Math.random() * Math.PI * 2,
      speed: speed,
      pause: 0, // pause timer in frames
      // --- Information vehicle properties ---
      infoBuffer: 0,
      state: "exploration", // or "gossip"
      gossipPartners: []  // use array as queue
    });
  }
}

function drawArena() {
  ctx.save();
  ctx.globalAlpha = 0.2;
  ctx.beginPath();
  ctx.arc(centerX, centerY, arenaRadius, 0, Math.PI * 2);
  ctx.fillStyle = '#fff';
  ctx.fill();
  ctx.restore();
}

function updateAnts() {
  // Head-to-head pause detection + info exchange
  for (let i = 0; i < ants.length; i++) {
    const antA = ants[i];
    if (antA.pause > 0) continue;
    const ax = antA.x + Math.cos(antA.angle) * ANT_SIZE;
    const ay = antA.y + Math.sin(antA.angle) * ANT_SIZE;
    for (let j = i + 1; j < ants.length; j++) {
      const antB = ants[j];
      if (antB.pause > 0) continue;
      const bx = antB.x + Math.cos(antB.angle) * ANT_SIZE;
      const by = antB.y + Math.sin(antB.angle) * ANT_SIZE;
      const dx = bx - ax;
      const dy = by - ay;
      const distSq = dx*dx + dy*dy;
      const headDist = ANT_SIZE * 1.5;
      if (distSq < headDist*headDist) {
        // pause both
        antA.pause = PAUSE_TIME_MIN + Math.floor(Math.random()*PAUSE_TIME_MAX);
        antB.pause = PAUSE_TIME_MIN + Math.floor(Math.random()*PAUSE_TIME_MAX);

        // --- info exchange on head-to-head meet ---
        if (
          antA.state === "gossip" && antB.state === "gossip" &&
          antA.infoBuffer > 0 && antB.infoBuffer > 0 &&
          !antA.gossipPartners.includes(j) && !antB.gossipPartners.includes(i)
        ) {
          antA.infoBuffer = Math.max(0, antA.infoBuffer - INFO_EXCHANGE_AMOUNT);
          antB.infoBuffer = Math.max(0, antB.infoBuffer - INFO_EXCHANGE_AMOUNT);
          // enqueue j in A's memory
          if (antA.gossipPartners.length >= GOSSIP_MEMORY_SIZE) antA.gossipPartners.shift();
          antA.gossipPartners.push(j);
          // enqueue i in B's memory
          if (antB.gossipPartners.length >= GOSSIP_MEMORY_SIZE) antB.gossipPartners.shift();
          antB.gossipPartners.push(i);
        }
      }
    }
  }

  for (let i = 0; i < ants.length; i++) {
    const ant = ants[i];
    if (ant.pause > 0) {
      ant.pause--;
      continue;
    }

    // --- State logic ---
    if (ant.state === "exploration") {
      // Wander
      ant.angle += (Math.random() - 0.5) * WANDER_STRENGTH;
      // Move
      const vx = Math.cos(ant.angle) * ant.speed;
      const vy = Math.sin(ant.angle) * ant.speed;
      ant.x += vx;
      ant.y += vy;
      // Increase infoBuffer by distance walked, scaled by INFO_ACCUM_RATE
      ant.infoBuffer += Math.sqrt(vx * vx + vy * vy) * INFO_ACCUM_RATE;
      if (ant.infoBuffer >= INFO_BUFFER_MAX) {
        ant.infoBuffer = INFO_BUFFER_MAX;
        ant.state = "gossip";
        ant.gossipPartners = [];
      }
    } else if (ant.state === "gossip") {
      // Try to approach the closest ant not in gossipPartners and within GOSSIP_RANGE*3
      let minDist = Infinity, target = null, targetIdx = -1;
      for (let j = 0; j < ants.length; j++) {
        if (i === j) continue;
        const antB = ants[j];
        if (ant.gossipPartners.includes(j)) continue;
        const dx = antB.x - ant.x;
        const dy = antB.y - ant.y;
        const distSq = dx * dx + dy * dy;
        // Only consider as target if antB has info to exchange and hasn't exchanged with ant
        if (
          distSq < (GOSSIP_RANGE * 3) * (GOSSIP_RANGE * 3) &&
          distSq > 1 && // avoid self
          antB.infoBuffer > 0 &&
          !antB.gossipPartners?.includes(i) &&
          distSq < minDist
        ) {
          minDist = distSq;
          target = antB;
          targetIdx = j;
        }
      }
      // If already exchanged with all possible, wander
      if (target) {
        // If already close enough to exchange, don't keep sticking, look for next
        if (Math.sqrt(minDist) < GOSSIP_RANGE * 1.1) {
          // Already close, so don't move toward this target anymore
          ant.angle += (Math.random() - 0.5) * WANDER_STRENGTH;
        } else {
          // Turn toward closest target
          const desiredAngle = Math.atan2(target.y - ant.y, target.x - ant.x);
          let da = desiredAngle - ant.angle;
          while (da > Math.PI) da -= 2 * Math.PI;
          while (da < -Math.PI) da += 2 * Math.PI;
          ant.angle += da * 0.2;
        }
      } else {
        // Wander if no target
        ant.angle += (Math.random() - 0.5) * WANDER_STRENGTH;
      }
      // Move (but do NOT accumulate infoBuffer)
      const vx = Math.cos(ant.angle) * ant.speed;
      const vy = Math.sin(ant.angle) * ant.speed;
      ant.x += vx;
      ant.y += vy;
      // --- Fix: check if infoBuffer is now <= 0 and switch to exploration ---
      if (ant.infoBuffer <= 0) {
        ant.infoBuffer = 0;
        ant.state = "exploration";
        ant.gossipPartners = [];
      }
    }
    // Boundary check
    const dx = ant.x - centerX;
    const dy = ant.y - centerY;
    const distSq = dx * dx + dy * dy;
    if (distSq > (arenaRadius - ANT_SIZE) * (arenaRadius - ANT_SIZE)) {
      const dist = Math.sqrt(distSq);
      const overlap = dist - (arenaRadius - ANT_SIZE);
      ant.x -= dx / dist * overlap;
      ant.y -= dy / dist * overlap;
      // Set angle to be parallel to the tangent at the boundary point,
      // choosing the tangent direction closest to the current angle, with some noise
      const angleToCenter = Math.atan2(dy, dx);
      const tangent1 = angleToCenter + Math.PI / 2;
      const tangent2 = angleToCenter - Math.PI / 2;
      // Find which tangent is closer to the current angle
      const delta1 = Math.abs(((tangent1 - ant.angle + Math.PI) % (2 * Math.PI)) - Math.PI);
      const delta2 = Math.abs(((tangent2 - ant.angle + Math.PI) % (2 * Math.PI)) - Math.PI);
      let newAngle = delta1 < delta2 ? tangent1 : tangent2;
      // Add adjustable noise
      newAngle += (Math.random() - 0.5) * BOUNDARY_TURN_NOISE;
      ant.angle = newAngle;
    }
  }

  // --- Collision avoidance: prevent overlap ---
  for (let i = 0; i < ants.length; i++) {
    for (let j = i + 1; j < ants.length; j++) {
      const a = ants[i];
      const b = ants[j];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const distSq = dx * dx + dy * dy;
      const minDist = ANT_SIZE * 2;
      if (distSq < minDist * minDist && distSq > 0.0001) {
        const dist = Math.sqrt(distSq);
        const overlap = (minDist - dist) / 2;
        const ox = dx / dist * overlap;
        const oy = dy / dist * overlap;
        a.x -= ox;
        a.y -= oy;
        b.x += ox;
        b.y += oy;
      }
    }
  }
}

function drawAnts() {
  ctx.save();
  for (let i = 0; i < ants.length; i++) {
    const ant = ants[i];
    // Color by state and infoBuffer
    let color;
    if (ant.state === "exploration") {
      // Blue (hue 220, low buffer) to White (high buffer)
      const t = ant.infoBuffer / INFO_BUFFER_MAX;
      // t=0: blue (220,100%,50%), t=1: white (any hue,0%,100%)
      const hue = 220;
      const sat = 100 * (1 - t);
      const light = 50 + 50 * t;
      color = `hsl(${hue}, ${sat}%, ${light}%)`;
    } else if (ant.state === "gossip") {
      // White (low buffer) to Red (hue 0, high buffer)
      const t = ant.infoBuffer / INFO_BUFFER_MAX;
      // Interpolate from white (0,0%,100%) to red (0,100%,50%)
      const hue = 0;
      const sat = 100 * t;
      const light = 100 - 50 * t;
      color = `hsl(${hue}, ${sat}%, ${light}%)`;
    } else {
      color = "#FFFF00";
    }
    ctx.fillStyle = color;
    // Draw a triangle pointing in the direction of ant.angle
    ctx.save();
    ctx.translate(ant.x, ant.y);
    ctx.rotate(ant.angle);
    ctx.beginPath();
    // Triangle: tip at (ANT_SIZE, 0), base at (-ANT_SIZE, -ANT_SIZE/1.5) and (-ANT_SIZE, +ANT_SIZE/1.5)
    ctx.moveTo(ANT_SIZE, 0);
    ctx.lineTo(-ANT_SIZE, -ANT_SIZE / 1.5);
    ctx.lineTo(-ANT_SIZE, ANT_SIZE / 1.5);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
  ctx.restore();
}

function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawArena();
  updateAnts();
  drawAnts();
  requestAnimationFrame(loop);
}

window.addEventListener('resize', () => {
  resizeCanvas();
  // Optionally, reposition ants or let them adapt
});

init();
loop();
</script>
</body>
</html>
`
